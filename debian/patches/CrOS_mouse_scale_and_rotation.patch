--- a/src/main.c
+++ b/src/main.c
@@ -550,6 +550,8 @@
         initPerScreenCallbacks (screen_info);
 
         XDefineCursor (main_display_info->dpy, screen_info->xroot, myDisplayGetCursorRoot(main_display_info));
+	myScreenSetCrosDisplayProps(screen_info);
+	eventXfwmRawFilterInit(main_display_info->dpy, screen_info);
     }
 
     /* No screen to manage, give up */
--- a/src/screen.c
+++ b/src/screen.c
@@ -33,6 +33,7 @@
 #include <gtk/gtk.h>
 #include <pango/pango.h>
 #include <libxfce4util/libxfce4util.h>
+#include <math.h>
 
 #ifdef HAVE_RENDER
 #include <X11/extensions/Xrender.h>
@@ -757,6 +758,14 @@
     screen_info->cache_monitor.y = -1;
     screen_info->cache_monitor.width = 0;
     screen_info->cache_monitor.height = 0;
+    screen_info->cache_monitor_mm.x = -1;
+    screen_info->cache_monitor_mm.y = -1;
+    screen_info->cache_monitor_mm.width = 0;
+    screen_info->cache_monitor_mm.height = 0;
+    screen_info->cache_monitor_cros.x = -1;
+    screen_info->cache_monitor_cros.y = -1;
+    screen_info->cache_monitor_cros.width = 0;
+    screen_info->cache_monitor_cros.height = 0;
 }
 
 /*
@@ -768,7 +777,9 @@
 {
     gint dx, dy, center_x, center_y, num_monitors, i;
     guint32 distsquare, min_distsquare;
-    GdkRectangle monitor, nearest_monitor = { G_MAXINT, G_MAXINT, 0, 0 };
+    GdkRectangle monitor, monitor_mm, nearest_monitor, nearest_monitor_mm =
+	{ G_MAXINT, G_MAXINT, 0, 0 };
+    gint internal = 0;
 
     g_return_if_fail (screen_info != NULL);
     g_return_if_fail (rect != NULL);
@@ -792,11 +803,17 @@
 
         monitor_index = myScreenGetMonitorIndex (screen_info, i);
         gdk_screen_get_monitor_geometry (screen_info->gscr, monitor_index, &monitor);
+	monitor_mm = monitor;
+	monitor_mm.width = gdk_screen_get_monitor_width_mm (screen_info->gscr, monitor_index);
+	monitor_mm.height = gdk_screen_get_monitor_height_mm (screen_info->gscr, monitor_index);
 
         if ((x >= monitor.x) && (x < (monitor.x + monitor.width)) &&
             (y >= monitor.y) && (y < (monitor.y + monitor.height)))
         {
             screen_info->cache_monitor = monitor;
+	    screen_info->cache_monitor_mm = monitor_mm;
+	    screen_info->cache_monitor_internal =
+		myScreenGetMonitorInternal(screen_info, monitor_index);
             *rect = screen_info->cache_monitor;
             return;
         }
@@ -813,13 +830,41 @@
         {
             min_distsquare = distsquare;
             nearest_monitor = monitor;
+	    nearest_monitor_mm = monitor_mm;
+	    internal = myScreenGetMonitorInternal(screen_info, monitor_index);
         }
     }
 
     screen_info->cache_monitor = nearest_monitor;
+    screen_info->cache_monitor_mm = nearest_monitor_mm;
+    screen_info->cache_monitor_internal = internal;
     *rect = screen_info->cache_monitor;
 }
 
+void
+myScreenFindMonitorMMAtPoint (ScreenInfo *screen_info, gint x, gint y, GdkRectangle *rect)
+{
+    GdkRectangle monitor;
+
+    myScreenFindMonitorAtPoint (screen_info, x, y, &monitor);
+    *rect = screen_info->cache_monitor_mm;
+}
+
+void
+myScreenScaleAtPoint (ScreenInfo *screen_info, gint x, gint y, float *scale_factor) {
+    GdkRectangle rect;
+    float dpi;
+
+    myScreenFindMonitorMMAtPoint (screen_info, x, y, &rect);
+    dpi = screen_info->cache_monitor.width / (screen_info->cache_monitor_mm.width / 25.4);
+
+    if (dpi <= 0) {
+	dpi = 96.0f;
+    }
+
+    *scale_factor = dpi/96.0f;
+}
+
 gboolean
 myScreenUpdateFontHeight (ScreenInfo *screen_info)
 {
@@ -848,3 +893,83 @@
 
     return FALSE;
 }
+
+void myScreenChangeCrosProp(ScreenInfo *screenInfo, char *prop, int value) {
+    glong    *data;
+    Atom name, type;
+
+    data = g_malloc(sizeof(glong));
+    data[0] = value;
+    name = XInternAtom(screenInfo->display_info->dpy, prop, FALSE);
+    type = XInternAtom(screenInfo->display_info->dpy, "CARDINAL", FALSE);
+    XChangeProperty(screenInfo->display_info->dpy,
+		    screenInfo->xroot,
+		    name,
+		    type,
+		    32,
+		    PropModeReplace,
+		    (unsigned char *)data,
+		    1);
+
+    g_free(data);
+}
+
+gboolean myScreenSetCrosDisplayProps (ScreenInfo *screen_info) {
+    float scale_factor;
+    const float scale_factors[] = {1.0f, 1.0f, 1.25f, 1.33f, 1.4f, 1.5f, 1.8f,
+					2.0f, 2.5f, 3.0f};
+    int i, num_factors;
+    float smallest_diff, diff, new_scale_factor;
+    Rotation rotation;
+    XRRScreenConfiguration *conf;
+    Window dr, window;
+    unsigned int modifiers;
+    int x, y, wx, wy;
+
+    XQueryPointer (myScreenGetXDisplay (screen_info), screen_info->xroot,
+                   &dr, &window, &x, &y, &wx, &wy, &modifiers);
+
+    /* Cache system */
+    if ((x >= screen_info->cache_monitor_cros.x) && (x < screen_info->cache_monitor_cros.x + screen_info->cache_monitor_cros.width) &&
+        (y >= screen_info->cache_monitor_cros.y) && (y < screen_info->cache_monitor_cros.y + screen_info->cache_monitor_cros.height))
+    {
+        return TRUE;
+    }
+
+    myScreenScaleAtPoint (screen_info, x, y, &scale_factor);
+    screen_info->cache_monitor_cros = screen_info->cache_monitor;
+    smallest_diff = diff = 0;
+    new_scale_factor = scale_factor;
+    num_factors = sizeof(scale_factors)/sizeof(scale_factors[0]);
+    for (i = 0; i < num_factors; i++) {
+	diff = fabs(scale_factor - scale_factors[i]);
+	if (!i || diff < smallest_diff) {
+	    smallest_diff = diff;
+	    new_scale_factor = scale_factors[i];
+	}
+    }
+
+    scale_factor = new_scale_factor;
+
+    conf = XRRGetScreenInfo(screen_info->display_info->dpy, screen_info->xroot);
+    XRRConfigCurrentConfiguration(conf, &rotation);
+
+    myScreenChangeCrosProp(screen_info, "_CHROME_DISPLAY_ROTATION", rotation);
+    myScreenChangeCrosProp(screen_info, "_CHROME_DISPLAY_SCALE_FACTOR", (int)(scale_factor * 100));
+    myScreenChangeCrosProp(screen_info, "_CHROME_DISPLAY_INTERNAL", screen_info->cache_monitor_internal);
+
+    return TRUE;
+}
+
+gint myScreenGetMonitorInternal(ScreenInfo *screen_info, gint monitor_index) {
+    gchar *plug;
+    gint internal = 0;
+
+    plug = gdk_screen_get_monitor_plug_name (screen_info->gscr, monitor_index);
+    if (!strcmp(plug, "eDP1")) {
+	internal = 1;
+    }
+    g_free(plug);
+
+    return internal;
+}
--- a/src/screen.h
+++ b/src/screen.h
@@ -120,6 +120,9 @@
 
     /* Monitor search caching */
     GdkRectangle cache_monitor;
+    GdkRectangle cache_monitor_mm;
+    GdkRectangle cache_monitor_cros;
+    gint cache_monitor_internal;
     gint num_monitors;
     GArray *monitors_index;
 
@@ -246,6 +249,19 @@
                                                                  gint,
                                                                  gint,
                                                                  GdkRectangle *);
+void                     myScreenFindMonitorMMAtPoint           (ScreenInfo *screen_info,
+								 gint x, gint y,
+								 GdkRectangle *rect);
+void                     myScreenScaleAtPoint                   (ScreenInfo *screen_info,
+								 gint x,
+								 gint y,
+								 float *scale_factor);
+void                     myScreenChangeCrosProp                 (ScreenInfo *screenInfo,
+								 char *prop,
+								 int value);
+gboolean                 myScreenSetCrosDisplayProps            (ScreenInfo *screen_info);
+gint                     myScreenGetMonitorInternal        (ScreenInfo *screen_info,
+								 gint monitor_index);
 gboolean                 myScreenUpdateFontHeight               (ScreenInfo *);
 
 #endif /* INC_SCREEN_H */
--- a/configure.ac
+++ b/configure.ac
@@ -78,7 +78,7 @@
 AC_SUBST([MATH_LIBS])
 
 dnl Check for i18n support
-XDT_I18N([am ar ast be bg bn ca cs da de el en_AU en_GB eo es et eu fi fr gl he hr hu id is it ja kk ko lt lv ms nb nl nn oc pa pl pt_BR pt ro ru si sk sl sq sr sv te th tr ug uk ur_PK ur vi zh_CN zh_HK zh_TW ])
+XDT_I18N([ am ar ast be bg bn ca cs da de el en_AU en_GB eo es et eu fi fr gl he hr hu id is it ja kk ko lt lv ms nb nl nn oc pa pl pt_BR pt ro ru si sk sl sq sr sv te th tr ug uk ur_PK ur vi zh_CN zh_HK zh_TW ])
 
 dnl Check for X11 window system
 XDT_CHECK_LIBX11_REQUIRE
@@ -190,6 +190,28 @@
 AC_SUBST([RANDR_LIBS])
 
 dnl
+dnl Xi extension
+dnl
+AC_ARG_ENABLE([xi],
+AC_HELP_STRING([--enable-xi], [try to use the xi extension])
+AC_HELP_STRING([--disable-xi], [don't try to use the xi extension]),
+  [], [enable_xi=yes])
+XI_LIBS=
+have_xi="no"
+if test x"$enable_xi" = x"yes"; then
+    have_xi="no"
+    ac_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS $LIBX11_CFLAGS"
+    AC_CHECK_LIB([Xi], [XIQueryVersion],
+                 [ have_xi="yes"
+                   XI_LIBS="-lXi"
+                   AC_DEFINE([HAVE_XI], [1], [Define to enable xi])
+                 ],[])
+    CFLAGS="$ac_CFLAGS"
+fi
+AC_SUBST([XI_LIBS])
+
+dnl
 dnl Xcomposite and related extensions
 dnl
 compositor="no"
@@ -265,6 +287,7 @@
 echo "  XSync support:                $have_xsync"
 echo "  Render support:               $have_render"
 echo "  Xrandr support:               $have_xrandr"
+echo "  XI support:                   $have_xi"
 echo "  Embedded compositor:          $compositor"
 echo "  KDE systray protocol proxy:   $kde_systray"
 echo
--- a/src/event_filter.c
+++ b/src/event_filter.c
@@ -28,9 +28,12 @@
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 #include <X11/Xlib.h>
+#include <X11/extensions/XInput2.h>
 
 #include <libxfce4util/libxfce4util.h>
 #include "event_filter.h"
+#include "screen.h"
+#include "display.h"
 
 static eventFilterStatus
 default_event_filter (XEvent * xevent, gpointer data)
@@ -161,6 +164,86 @@
     return (loop & EVENT_FILTER_REMOVE) ? GDK_FILTER_REMOVE : GDK_FILTER_CONTINUE;
 }
 
+//From: http://keithp.com/blogs/Cursor_tracking/
+/* Return 1 if XI2 is available, 0 otherwise */
+int has_xi2(Display *dpy)
+{
+    int major, minor;
+    int rc;
+
+    /* We support XI 2.2 */
+    major = 2;
+    minor = 2;
+
+    rc = XIQueryVersion(dpy, &major, &minor);
+    if (rc == BadRequest) {
+      TRACE("No XI2 support. Server supports version %d.%d only.", major, minor);
+    return 0;
+    } else if (rc != Success) {
+      TRACE("Internal Error! This is a bug in Xlib.");
+    }
+
+    TRACE("XI2 supported. Server provides version %d.%d.", major, minor);
+
+    return 1;
+}
+
+//From: http://keithp.com/blogs/Cursor_tracking/
+void select_raw_motion_events(Display *dpy, Window win)
+{
+    XIEventMask evmasks[1];
+    unsigned char mask1[(XI_LASTEVENT + 7)/8];
+
+    memset(mask1, 0, sizeof(mask1));
+
+    /* select for button and key events from all master devices */
+    XISetMask(mask1, XI_RawMotion);
+
+    evmasks[0].deviceid = XIAllMasterDevices;
+    evmasks[0].mask_len = sizeof(mask1);
+    evmasks[0].mask = mask1;
+
+    XISelectEvents(dpy, win, evmasks, 1);
+    XFlush(dpy);
+}
+
+static GdkFilterReturn
+eventXfwmRawFilter (GdkXEvent * gdk_xevent, GdkEvent * event, gpointer data) {
+    XGenericEventCookie *cookie;
+    XEvent *xevent;
+    ScreenInfo *screen_info;
+    int ret;
+
+    ret = GDK_FILTER_CONTINUE;
+    screen_info = (ScreenInfo *) data;
+    xevent = (XEvent *) gdk_xevent;
+    cookie = &xevent->xcookie;
+    if (cookie->type != GenericEvent)
+	return ret;
+
+    switch (cookie->evtype) {
+    case XI_RawMotion:
+	myScreenSetCrosDisplayProps(screen_info);
+	break;
+    }
+
+    return ret;
+}
+
+gboolean eventXfwmRawFilterInit(Display *dpy, gpointer data) {
+  ScreenInfo *screen_info;
+
+  screen_info = (ScreenInfo *) data;
+  if (!has_xi2(dpy)) {
+    return FALSE;
+  }
+
+  select_raw_motion_events(dpy, screen_info->xroot);
+  gdk_window_add_filter (NULL, eventXfwmRawFilter, data);
+
+  return TRUE;
+}
+
 eventFilterStack *
 eventFilterPush (eventFilterSetup *setup, XfwmFilter filter, gpointer data)
 {
--- a/src/event_filter.h
+++ b/src/event_filter.h
@@ -64,5 +64,6 @@
 eventFilterStack        *eventFilterPop                         (eventFilterSetup *);
 eventFilterSetup        *eventFilterInit                        (gpointer);
 void                     eventFilterClose                       (eventFilterSetup *);
+gboolean                eventXfwmRawFilterInit                  (Display *dpy, gpointer screen_info);
 
 #endif /* INC_EVENT_FILTER_H */
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -102,6 +102,7 @@
 	$(RENDER_LIBS)							\
 	$(COMPOSITOR_LIBS)						\
 	$(RANDR_LIBS) 							\
+	$(XI_LIBS) 							\
 	$(MATH_LIBS)
 
 EXTRA_DIST = 								\
--- a/src/events.c
+++ b/src/events.c
@@ -2779,6 +2779,7 @@
     }
 
     clientScreenResize (screen_info, FALSE);
+    myScreenSetCrosDisplayProps (screen_info);
 }
 
 /*
@@ -2837,6 +2838,7 @@
     }
 
     clientScreenResize (screen_info, (screen_info->num_monitors < previous_num_monitors));
+    myScreenSetCrosDisplayProps (screen_info);
 }
 
 void
